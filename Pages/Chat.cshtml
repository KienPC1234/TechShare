@page
@model LoginSystem.Pages.ChatModel
@{
    ViewData["Title"] = "Chat";
}

<style>
    .online-indicator {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: limegreen;
        margin-left: 5px;
    }
</style>

<div class="container mt-4">
    <div class="row">
        <!-- User Search -->
        <div class="col-md-4">
            <h3>Users</h3>
            <div class="input-group mb-3">
                <input type="text" class="form-control" placeholder="Search by username or display name..." data-bind="textInput: searchQuery">
                <button class="btn btn-primary" data-bind="click: searchUsers, enable: !isSearching()">Search</button>
            </div>
            <div data-bind="visible: errorMessage" class="alert alert-danger" role="alert" data-bind="text: errorMessage"></div>
            <ul class="list-group" data-bind="foreach: users">
                <li class="list-group-item d-flex align-items-center" data-bind="click: $parent.selectUser, css: { active: $data.id === $parent.selectedUserId }">
                    <img data-bind="attr: { src: $data.avatarUrl ? $data.avatarUrl : '/images/default-avatar.png' }" class="rounded-circle me-2" style="width: 40px; height: 40px;" alt="Avatar">
                    <div>
                        <strong data-bind="text: $data.displayName ? $data.displayName : ($data.userName || 'Unknown')"></strong>
                        <!-- ko if: $parent.onlineUsers().includes($data.id) -->
                        <span class="online-indicator"></span>
                        <!-- /ko -->
                        <br>
                        <small data-bind="text: $data.userName || 'No Username'"></small>
                    </div>
                </li>
            </ul>
        </div>
        <!-- Chat Area -->
        <div class="col-md-8">
            <h3>Chat with <span data-bind="text: selectedUserName"></span></h3>
            <div class="card">
                <div class="card-body" style="height: 400px; overflow-y: auto;" data-bind="foreach: messages">
                    <div class="mb-2" data-bind="css: { 'text-end': senderId === '@Model.CurrentUserId' }">
                        <div class="d-flex" data-bind="css: { 'justify-content-end': senderId === '@Model.CurrentUserId' }">
                            <img data-bind="attr: { src: senderAvatar ? senderAvatar : '/images/default-avatar.png' }" class="rounded-circle me-2" style="width: 30px; height: 30px;">
                            <div>
                                <strong data-bind="text: senderName || 'Unknown'"></strong>
                                <div class="p-2 rounded" data-bind="css: { 'bg-primary text-white': senderId === '@Model.CurrentUserId', 'bg-light': senderId !== '@Model.CurrentUserId' }">
                                    <!-- ko if: contentType === 'text' -->
                                    <span data-bind="text: content"></span>
                                    <!-- /ko -->
                                    <!-- ko if: contentType === 'image' -->
                                    <img data-bind="attr: { src: content }" style="max-width: 200px;" alt="Image">
                                    <!-- /ko -->
                                    <!-- ko if: contentType === 'video' -->
                                    <video controls style="max-width: 200px;">
                                        <source data-bind="attr: { src: content }" type="video/mp4">
                                        Your browser does not support the video tag.
                                    </video>
                                    <!-- /ko -->
                                </div>
                                <small class="text-muted" data-bind="text: new Date(createdAt).toLocaleString()"></small>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card-footer">
                    <div class="input-group mb-2">
                        <input type="text" class="form-control" placeholder="Type a message..." data-bind="textInput: newMessage, enable: selectedUserId">
                        <button class="btn btn-primary" data-bind="click: sendMessage, enable: selectedUserId() && newMessage().length > 0">Send</button>
                    </div>
                    <div class="input-group">
                        <input type="file" class="form-control" id="fileUpload" accept="image/jpeg,image/png,image/gif,image/webp,video/mp4,video/webm,video/ogg" data-bind="enable: selectedUserId, event: { change: fileSelected }">
                        <button class="btn btn-primary" data-bind="click: uploadFile, enable: selectedUserId() && hasFile()">Upload</button>
                    </div>
                    <small class="text-muted">Select a file (image or video) to upload.</small>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/knockout@3.5.1/build/output/knockout-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@@microsoft/signalr@8.0.7/dist/browser/signalr.min.js"></script>
    <script>
        function ChatViewModel() {
            var self = this;
            self.searchQuery = ko.observable('');
            self.users = ko.observableArray([]);
            self.messages = ko.observableArray([]);
            self.newMessage = ko.observable('');
            self.selectedUserId = ko.observable(null);
            self.selectedUserName = ko.observable('');
            self.currentUserId = '@Model.CurrentUserId';
            self.isSearching = ko.observable(false);
            self.errorMessage = ko.observable('');
            self.onlineUsers = ko.observableArray([]);
            self.hasFile = ko.observable(false);
            let searchAbortController = null;
            let searchTimeout = null;

            // SignalR connection
            const connection = new signalR.HubConnectionBuilder()
                .withUrl('/mesHub')
                .withAutomaticReconnect()
                .build();

            connection.on('ReceiveMessage', function (message) {
                console.log('Received message:', message);
                self.messages.push(message);
                const chatBody = document.querySelector('.card-body');
                chatBody.scrollTop = chatBody.scrollHeight;
            });

            connection.on('UserConnected', function (userId, displayName) {
                console.log(`${displayName} connected`);
                if (!self.onlineUsers().includes(userId)) {
                    self.onlineUsers.push(userId);
                }
            });

            connection.on('UserDisconnected', function (userId, displayName) {
                console.log(`${displayName} disconnected`);
                self.onlineUsers.remove(userId);
            });

            connection.on('UpdateOnlineUsers', function (onlineUserIds) {
                console.log('Online users updated:', onlineUserIds);
                self.onlineUsers(onlineUserIds);
            });

            connection.start().catch(function (err) {
                console.error('SignalR connection error:', err);
                self.errorMessage('Failed to connect to chat server. Please refresh.');
            });

            // Load first 50 users
            self.loadDefaultUsers = function () {
                self.isSearching(true);
                self.errorMessage('');
                if (searchAbortController) {
                    searchAbortController.abort();
                }
                searchAbortController = new AbortController();
                fetch('/api/chat/users', { signal: searchAbortController.signal })
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        return response.json();
                    })
                    .then(data => {
                        console.log('Loaded default users:', data);
                        self.users(data);
                    })
                    .catch(err => {
                        if (err.name === 'AbortError') {
                            console.log('Default users fetch aborted');
                            return;
                        }
                        console.error('Error loading default users:', err);
                        self.errorMessage('Failed to load users: ' + err.message);
                    })
                    .finally(() => {
                        self.isSearching(false);
                        searchAbortController = null;
                    });
            };

            // Search users with debounce
            self.searchUsers = function () {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    self.isSearching(true);
                    self.errorMessage('');
                    const query = self.searchQuery().trim();
                    if (searchAbortController) {
                        searchAbortController.abort();
                    }
                    searchAbortController = new AbortController();
                    const url = query ? `/api/chat/users/search?query=${encodeURIComponent(query)}` : '/api/chat/users';
                    fetch(url, { signal: searchAbortController.signal })
                        .then(response => {
                            if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            return response.json();
                        })
                        .then(data => {
                            console.log('Search results:', data);
                            self.users(data);
                        })
                        .catch(err => {
                            if (err.name === 'AbortError') {
                                console.log('Search fetch aborted');
                                return;
                            }
                            console.error('Search error:', err);
                            self.errorMessage('Search failed: ' + err.message);
                        })
                        .finally(() => {
                            self.isSearching(false);
                            searchAbortController = null;
                        });
                }, 300);
            };

            // Select a user
            self.selectUser = function (user) {
                console.log('Selected user:', user);
                self.selectedUserId(user.id);
                self.selectedUserName(user.displayName || user.userName || 'Unknown');
                self.messages([]);
                fetch(`/api/chat/messages?receiverId=${user.id}`)
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        return response.json();
                    })
                    .then(data => {
                        console.log('Loaded messages:', data);
                        self.messages(data);
                        const chatBody = document.querySelector('.card-body');
                        chatBody.scrollTop = chatBody.scrollHeight;
                    })
                    .catch(err => {
                        console.error('Error loading messages:', err);
                        self.errorMessage('Failed to load messages: ' + err.message);
                    });
            };

            // Handle file selection
            self.fileSelected = function (data, event) {
                const fileInput = event.target;
                console.log('File input changed:', {
                    files: fileInput.files,
                    fileCount: fileInput.files.length,
                    fileName: fileInput.files[0]?.name
                });
                self.hasFile(fileInput.files && fileInput.files.length > 0);
            };

            // Send text message
            self.sendMessage = function () {
                if (!self.newMessage() || !self.selectedUserId()) {
                    console.warn('Cannot send: Empty message or no user selected', {
                        newMessage: self.newMessage(),
                        selectedUserId: self.selectedUserId()
                    });
                    return;
                }

                let contentType = 'text';
                const message = self.newMessage().trim();
                if (!message) {
                    console.warn('Cannot send: Empty message after trim');
                    self.errorMessage('Message cannot be empty.');
                    return;
                }

                console.log('Sending message:', {
                    senderId: self.currentUserId,
                    receiverId: self.selectedUserId(),
                    message: message,
                    contentType: contentType
                });

                connection.invoke('SendMessage', self.currentUserId, self.selectedUserId(), message, contentType)
                    .then(() => {
                        console.log('Message sent successfully');
                    })
                    .catch(function (err) {
                        console.error('Send message error:', err);
                        self.errorMessage('Failed to send message: ' + err.message);
                    });

                self.newMessage('');
            };

            // Upload file
            self.uploadFile = function () {
                const fileInput = document.getElementById('fileUpload');
                console.log('Upload attempted:', {
                    files: fileInput.files,
                    fileCount: fileInput.files ? fileInput.files.length : 0,
                    fileName: fileInput.files[0]?.name,
                    selectedUserId: self.selectedUserId()
                });
                if (!fileInput.files || fileInput.files.length === 0 || !self.selectedUserId()) {
                    console.warn('Cannot upload: No file selected or no user selected', {
                        files: fileInput.files,
                        selectedUserId: self.selectedUserId()
                    });
                    self.errorMessage('Please select a file and a user.');
                    return;
                }

                const file = fileInput.files[0];
                const maxSize = 10 * 1024 * 1024; // 10MB
                if (file.size > maxSize) {
                    console.warn('File too large:', file.size);
                    self.errorMessage('File size exceeds 10MB limit.');
                    return;
                }

                const formData = new FormData();
                formData.append('file', file);
                console.log('FormData prepared:', {
                    fileName: file.name,
                    fileSize: file.size,
                    fileType: file.type
                });

                fetch('/api/chat/upload', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        return response.json();
                    })
                    .then(data => {
                        console.log('File uploaded:', data);
                        const content = data.fileUrl;
                        let contentType = 'text';
                        if (file.type.startsWith('image/')) {
                            contentType = 'image';
                        } else if (file.type.startsWith('video/')) {
                            contentType = 'video';
                        }

                        console.log('Sending file message:', {
                            senderId: self.currentUserId,
                            receiverId: self.selectedUserId(),
                            message: content,
                            contentType: contentType
                        });

                        return connection.invoke('SendMessage', self.currentUserId, self.selectedUserId(), content, contentType);
                    })
                    .then(() => {
                        console.log('File message sent successfully');
                        self.hasFile(false);
                        fileInput.value = '';
                    })
                    .catch(err => {
                        console.error('File upload or message error:', err);
                        self.errorMessage('Failed to upload file or send message: ' + err.message);
                    });
            };

            // Initialize
            self.loadDefaultUsers();
        }

        ko.applyBindings(new ChatViewModel());
    </script>
}